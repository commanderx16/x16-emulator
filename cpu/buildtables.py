# *******************************************************************************************
# *******************************************************************************************
#
#		File:		buildtables.py
#		Date:		3rd September 2019
#		Purpose:	Creates files tables.h from the .opcodes descriptors
#					Creates disassembly include file.
#		Author:		Paul Robson (paul@robson.org.uk)
#
# *******************************************************************************************
# *******************************************************************************************

import re
#
#							Load in a source file with opcode descriptors
#
def loadSource(srcFile):
	#
	#		Load file
	#
	src = [x.strip() for x in open(srcFile).readlines() if x.strip() != ""]
	src = [x for x in src if not x.startswith(";")]
	#
	#		Import opcodes
	#
	for l in src:
		m = re.match("^(\\w+)\\s+(\\w+)\\s+(\\d)\\s+\\$([0-9a-fA-F]+)$",l)
		assert m is not None,"Format "+l
		opcode = int(m.group(4),16)
		assert opcodes[opcode] is None,"Duplicate {0:02x}".format(opcode)
		opcodes[opcode] = { "mode":m.group(2),"action":m.group(1),"cycles":m.group(3),"opcode":opcode }

#
#									Fill unused slots with NOPs
#
def fillNop():
	for i in range(0,256):
		if opcodes[i] is None:
			opcodes[i] = { "mode":"imp","action":"nop","cycles":"2","opcode":i }
#
#										  Output a table
#
def generateTable(h,header,element):
	s = 5 if element == "cycles" else 5
	h.write("\n{0}\n".format(header))
	h.write("/*        |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  A  |  B  |  C  |  D  |  E  |  F  |     */\n")
	for row in range(0,16):
		elements = ",".join([("         "+opcodes[x][element])[-s:] for x in range(row*16,row*16+16)])
		h.write("/* {0:X} */ {3}  {1}{2} /* {0:X} */\n".format(row,elements," " if row == 15 else ","," " if element == "action" else ""))
	h.write("};\n")
#
#							Convert opcode structure to mnemonic
#	
def convertMnemonic(opInfo):
	modeStr = { "imp":"", "imm":"#$%02x", "zp":"$%02x", "rel":"$%02x", "zpx":"$%02x,x", 
				"zpy":"$%02x,y","abso":"$%04x", "absx":"$%04x,x", "absy":"$%04x,y", 
				"ainx":"($%04x,x)", "indy":"($%02x),y", "indx":"($%02x,x)", "ind":"($%04x)", 
				"ind0":"($%02x)", "acc":"a" }
	return opInfo["action"]+" "+modeStr[opInfo["mode"]]
#
#										Load in opcodes
#
opcodes = [ None ] * 256
loadSource("6502.opcodes")
loadSource("65c02.opcodes")
fillNop()
#
#										Create tables.h
#
h = open("tables.h","w")
h.write("/* Generated by buildtables.py */\n")
generateTable(h,"static void (*addrtable[256])() = {","mode")
generateTable(h,"static void (*optable[256])() = {","action")
generateTable(h,"static const uint32_t ticktable[256] = {","cycles")
h.close()
#
#										Create disassembly file.
#
mnemonics = [convertMnemonic(opcodes[x]) for x in range(0,256)]
mnemonics = ",".join(['"'+x+'"' for x in mnemonics])
h = open("mnemonics.h","w")
h.write("/* Generated by buildtables.py */\n")
h.write("static char *mnemonics[256] = {{ {0} }};\n".format(mnemonics))
h.close()
